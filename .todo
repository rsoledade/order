Implemente um microservi√ßo chamado order, utilizando .NET Core WebAPI, PostgreSQL como banco de dados e o padr√£o de arquitetura DDD com Clean Architecture. 
Todas as opera√ß√µes (comandos e consultas) devem ser orquestradas utilizando o MediatR como bus de mensagens interno, garantindo separa√ß√£o clara de responsabilidades, 
isolamento entre camadas e ader√™ncia a boas pr√°ticas como CQRS, SOLID, YAGNI e KISS.

üì¶ REGRAS DE NEG√ìCIO
Receber pedidos contendo um ou mais produtos com valor individual.

Calcular o valor total do pedido somando os valores dos produtos.

Rejeitar pedidos duplicados com base no externalId ou hash.

Persistir pedidos e seus produtos no banco PostgreSQL.

Gerenciar e atualizar o status do pedido (RECEIVED, PROCESSED, DUPLICATE, ERROR etc).

Ap√≥s o processamento, emitir um evento de p√≥s-processamento para downstreams.

üß± ESTRUTURA EM CAMADAS (DDD + CLEAN ARCHITECTURE + MEDIATR)
1. Domain
Regras puras de neg√≥cio e abstra√ß√µes.

Cont√©m:

Entities: Order, Product

ValueObjects: ex. Money, OrderId

Enums: OrderStatus

Interfaces: IOrderRepository, IUnitOfWork, IEventPublisher

Domain Services: regras que envolvem mais de uma entidade

2. Application
Respons√°vel pelos casos de uso (Use Cases), implementados via MediatR:

Cada comando ou consulta deve ser um IRequest<T> ou IRequest

Handlers devem implementar IRequestHandler<>

Exemplo:

RegisterOrderCommand / RegisterOrderCommandHandler

GetOrdersQuery / GetOrdersQueryHandler

Tamb√©m cont√©m:

DTOs de entrada e sa√≠da

Validators com FluentValidation

Interfaces de servi√ßos externos ou mensageria

3. Infrastructure
Implementa√ß√µes t√©cnicas:

OrderRepository usando EF Core para PostgreSQL

EventPublisher para envio de eventos (ex: RabbitMQ, Kafka ou mockado)

UnitOfWork para controle transacional

AutoMapper para mapear DTOs e entidades

Implementa as interfaces definidas no dom√≠nio e na aplica√ß√£o

4. Presentation (API)
WebAPI ASP.NET Core com os seguintes endpoints:

POST /orders: recebe pedidos

GET /orders: retorna pedidos com produtos e status

Cada endpoint deve enviar comandos/consultas para o MediatR, que invoca os handlers apropriados.

N√£o deve conter l√≥gica de neg√≥cio nem de persist√™ncia.

üîÅ EVENTO DE P√ìS-PROCESSAMENTO
Ap√≥s o processamento de um pedido:

Um evento OrderProcessedEvent deve ser publicado com os dados: orderId, totalAmount, status, products, timestamp

O evento deve ser enviado via um publisher implementado pela interface IEventPublisher

Esse evento representa a comunica√ß√£o com o sistema B, via mensageria ou fila de eventos

A publica√ß√£o ocorre apenas ap√≥s persist√™ncia com sucesso

‚öôÔ∏è TECNOLOGIAS E PR√ÅTICAS
Backend: .NET Core WebAPI

Banco de dados: PostgreSQL com EF Core

Orquestra√ß√£o de opera√ß√µes: MediatR

Arquitetura: DDD + Clean Architecture

Princ√≠pios: SOLID, YAGNI, KISS, Clean Code

Valida√ß√µes: FluentValidation

Logs: estruturados

Testes: unit√°rios para Domain e Application

Migrations: EF Core

Mensageria: RabbitMQ, Kafka ou mock (simulado)

Docker: recomendado